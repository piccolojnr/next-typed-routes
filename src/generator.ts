import fs from "fs";
import path from "path";
import type { TypeGenerator } from "./types";
import { ensureDirectory } from "./utils";

/**
 * Type generator implementation
 */
export class NextTypeGenerator implements TypeGenerator {
    private routePrefix: string;

    constructor(routePrefix: string = "") {
        this.routePrefix = routePrefix;
    }

    /**
     * Generate TypeScript type definitions from discovered routes
     */
    generateTypes(routes: string[], outputPath: string): void {
        if (routes.length === 0) {
            console.warn("⚠️  No routes found. The generated type file will be empty.");
        }

        // Ensure output directory exists
        const outputDir = path.dirname(outputPath);
        ensureDirectory(outputDir);

        const union = routes.length > 0
            ? routes.map((r) => `  | "${this.routePrefix}${r}"`).join("\n")
            : '  | never';

        const typeContent = this.generateTypeContent(union, routes);
        const runtimeContent = this.generateRuntimeContent(routes);

        try {
            // Write type definitions
            fs.writeFileSync(outputPath, typeContent, 'utf8');

            // Write runtime functions
            const runtimePath = outputPath.replace('.d.ts', '.ts');
            fs.writeFileSync(runtimePath, runtimeContent, 'utf8');

            console.log(`✅ typed-routes.d.ts generated successfully with ${routes.length} route(s)`);
            console.log(`✅ typed-routes.ts generated successfully with ${routes.length} route(s)`);
            console.log(`📍 Output location: ${outputPath}`);
            console.log(`📍 Runtime location: ${runtimePath}`);

            if (routes.length > 0) {
                console.log(`📋 Generated routes:`);
                routes.forEach(route => console.log(`   - ${this.routePrefix}${route}`));
            }
        } catch (error) {
            console.error(`❌ Failed to write typed routes file: ${error}`);
            throw error;
        }
    }

    /**
     * Generate the TypeScript content
     */
    private generateTypeContent(union: string, routes: string[]): string {
        return [
            '// 🔒 AUTO-GENERATED FILE — DO NOT EDIT',
            `// Generated by next-typed-routes on ${new Date().toISOString()}`,
            '',
            'export type AppRoute =',
            union,
            ';',
            '',
        ].join('\n');
    }

    /**
     * Generate the runtime content for the isValidRoute function
     */
    private generateRuntimeContent(routes: string[]): string {
        const routeTemplates = routes.map(route => `  "${route}"`).join(',\n');
        return [
            '// 🔒 AUTO-GENERATED FILE — DO NOT EDIT',
            `// Generated by next-typed-routes on ${new Date().toISOString()}`,
            '',
            'export type AppRoute =',
            '  | never;', // This will be overridden by the typeContent
            '',
            '// Route templates for runtime validation',
            `const routeTemplates: AppRoute[] = [`,
            routeTemplates,
            '];',
            '',
            '// Runtime validation function',
            'export function isValidRoute(path: string): boolean {',
            '  return routeTemplates.some((template) => {',
            '    const regexStr = "^" + template.replace(/\\[.+?\\]/g, "[^/]+") + "$";',
            '    return new RegExp(regexStr).test(path);',
            '  });',
            '}',
            '',
        ].join('\n');
    }
}

/**
 * Factory function to create a type generator
 */
export function createTypeGenerator(routePrefix?: string): TypeGenerator {
    return new NextTypeGenerator(routePrefix);
} 