import fs from "fs";
import path from "path";
import type { TypeGenerator } from "./types";
import { ensureDirectory } from "./utils";
import { getDefaultOutputDir } from "./config";

/**
 * Type generator implementation
 */
export class NextTypeGenerator implements TypeGenerator {
    private routePrefix: string;

    constructor(routePrefix: string = "") {
        this.routePrefix = routePrefix;
    }

    /**
     * Generate TypeScript type definitions from discovered routes
     */
    generateTypes(routes: string[], outputPath: string): void {
        if (routes.length === 0) {
            console.warn("âš ï¸  No routes found. The generated type file will be empty.");
        }

        // Ensure output directory exists
        const outputDir = path.dirname(outputPath);
        ensureDirectory(outputDir);

        // Also ensure the main typed-routes directory exists
        const typedRoutesDir = getDefaultOutputDir();
        ensureDirectory(typedRoutesDir);

        // current working directory
        const currentDir = path.resolve();

        const union = routes.length > 0
            ? routes.map((r) => `  | "${this.routePrefix}${r}"`).join("\n")
            : '  | never';

        const typeContent = this.generateTypeContent(union, routes);
        // const barrelContent = this.generateBarrelContent(routes);

        try {
            // Write type definitions to generated directory (as .ts file for importability)
            const tsOutputPath = outputPath.replace('.d.ts', '.ts');
            fs.writeFileSync(tsOutputPath, typeContent, 'utf8');

            // Write barrel file to main typed-routes directory
            const barrelPath = path.join(typedRoutesDir, "route.ts");
            // fs.writeFileSync(barrelPath, barrelContent, 'utf8');
            // Copy route.ts to the shared directory
            // Use path relative to the library's bundled files in dist
            const librarySrcDir = path.join(__dirname, 'shared');
            const routePath = path.join(typedRoutesDir, "route.ts");
            fs.copyFileSync(path.join(librarySrcDir, 'route.ts'), routePath);
            // Copy react.tsx to the shared directory
            const reactPath = path.join(typedRoutesDir, "react.tsx");
            fs.copyFileSync(path.join(librarySrcDir, 'react.tsx'), reactPath);

            console.log(`âœ… Route types generated successfully with ${routes.length} route(s)`);
            console.log(`ðŸ“ Types location: ${tsOutputPath}`);
            console.log(`ðŸ“ Route utilities: ${barrelPath}`);
            console.log(`ðŸ“ React components: ${reactPath}`);

            if (routes.length > 0) {
                console.log(`ðŸ“‹ Generated routes:`);
                routes.forEach(route => console.log(`   - ${this.routePrefix}${route}`));
            }
        } catch (error) {
            console.error(`âŒ Failed to write typed routes file: ${error}`);
            throw error;
        }
    }

    /**
     * Generate the TypeScript type content
     */
    private generateTypeContent(union: string, routes: string[]): string {
        const routeTemplates = routes.map(route => `  "${route}"`).join(',\n');

        return [
            '// ðŸ”’ AUTO-GENERATED FILE â€” DO NOT EDIT',
            `// Generated by next-typed-routes on ${new Date().toISOString()}`,
            '',
            '/**',
            ' * Union type of all available routes in your Next.js application',
            ' */',
            'export type AppRoute =',
            union,
            ';',
            '',
            '/**',
            ' * Array of all route templates for runtime operations',
            ' */',
            'export const allRoutes: readonly AppRoute[] = [',
            routeTemplates,
            '] as const;',
            '',
            '/**',
            ' * Type alias for better developer experience',
            ' */',
            'export type TypedRoute = AppRoute;',
            '',
        ].join('\n');
    }

    /**
     * Generate the barrel file content that re-exports everything
     */
    private generateBarrelContent(routes: string[]): string {
        return [
            '// ðŸ”’ AUTO-GENERATED FILE â€” DO NOT EDIT',
            `// Generated by next-typed-routes on ${new Date().toISOString()}`,
            '',
            '// Re-export all types from generated files',
            'export type { AppRoute, TypedRoute } from "./generated/routes";',
            'export { allRoutes } from "./generated/routes";',
            '',
            '// Re-export runtime utilities from the library',
            'export { route } from "next-typed-routes";',
            '',
            '// Runtime validation function using generated routes',
            'import { allRoutes } from "./generated/routes";',
            '',
            '/**',
            ' * Validate if a given path matches any of the defined routes',
            ' * @param path - The path to validate',
            ' * @returns true if the path matches a defined route pattern',
            ' */',
            'export function isValidRoute(path: string): boolean {',
            '  return allRoutes.some((template) => {',
            '    const regexStr = "^" + template.replace(/\\[.+?\\]/g, "[^/]+") + "$";',
            '    return new RegExp(regexStr).test(path);',
            '  });',
            '}',
            '',
            '/**',
            ' * Get all available routes',
            ' * @returns Array of all route templates',
            ' */',
            'export function getAllRoutes(): readonly string[] {',
            '  return allRoutes;',
            '}',
            '',
        ].join('\n');
    }
}

/**
 * Factory function to create a type generator
 */
export function createTypeGenerator(routePrefix?: string): TypeGenerator {
    return new NextTypeGenerator(routePrefix);
} 